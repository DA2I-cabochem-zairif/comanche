#!/usr/bin/perl

use Socket;
if($#ARGV < 0){
    die("Usage : start, stop, status, reload\n");
}

# Récupère la commande
$commande = $ARGV[0];

#Configuration du serveur 
$pidServFile = ".pid";
charger_conf();

#Nombre de clients connecter
@client = ();


if($commande eq "start"){
    if(-f $pidServFile){
	die("Comanche est déjà en cours d'executions\n");
    }
    
    $pid = fork;
    if($pid != 0){
	open(PID, ">$pidServFile");
	print PID $pid;
	close(PID);
	exit 0;
    }else{
	print "Lancement du serveur en cour\n veuillez patientez...\n";
       
	socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);
	
	$port = $conf{"global"}{"port"};
	$addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidServFile); die("sockaddr_in\n"); };
	bind(SERVEUR, $addr) || do { unlink($pidServFile); die("[ERR] Le port $port est indisponible\n"); };
	listen(SERVEUR, SOMAXCONN) || do { unlink($pidServFile); die("listen $!\n"); };
	print "Serveur lancé sur le port $port \n";
	ajouterLog(date(),"start","local",$port,"","");
	while (accept(CLIENT,SERVEUR)){
	    autoflush CLIENT 1;

	    $pid = fork;
	    
	    if($pid == 0){

		$peer = getpeername(CLIENT);
                ($port, $iaddr) = sockaddr_in($peer);
                $ip = inet_ntoa($iaddr);

		$req = <CLIENT>;
		while(<CLIENT> =~ /^\r?\n/){}#on ne fait rien si le client n'envoie pas de requete
		
		$req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || print STDERR "Repondre 400 \n";

		

		$req = $1;

		@fichier = getFile($req); #retourne 404 ...
		$fichier = $fichier[1];
		
		unless(-f $fichier){
		    repondre404();
		}
		
		$reponse = readFile($fichier);

		print CLIENT "HTTP/1.1 200 OK\r\n" .
		             "Content-Type: text/html \r\n" .
			     "Content-length: " . length($reponse) . "\r\n\r\n" .
			     $reponse;
		
		
		close CLIENT;
		exit 0;
		
	    }
	}
	close CLIENT;
	close SERVEUR;

    }
}elsif($commande eq "stop"){
    kill QUIT, getpid() || die("Le serveur n'est pas en cour d'execution\n");
    unlink($pidServFile);
    ajouterLog(date(),"stop","local",$conf{"global"}{"port"},"","");
}elsif($commande eq "reload"){
    getpid() || die("Le serveur n'est pas en cour d'execution\n");
    chager_conf;
}elsif($commande eq "status"){

}


sub charger_conf
{
    # Vide la configuration
    undef %conf;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $cle    = $1;
            $valeur = $2;

            if($cle =~ /port/){         # Validation du port TCP
                die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
            } elsif($cle =~ /clients/){ # Validation du nombre de clients
                die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
            } elsif($cle =~ /default/){ # Validation du fichier par défaut
                die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
            } elsif($cle =~ /basedir/){ # Validation du dossier de base
                die("[Erreur configuration] Dossier de base inaccessible\n") unless(-d $valeur);
            }

            $conf{"global"}{$cle} = $valeur;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $conf{"routes"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $conf{"exec"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } 
    }
    close(CONFIG);
}

# Retourne la route associée à la requête
sub getPath
{
    $req = $_[0];

    # Gestion du dossier de base
    $basedir = "";
    if (exists $config{"global"}{"basedir"}) {
        $basedir = $config{"global"}{"basedir"};
    }

    # Parcours de toutes les règles de réécriture (routes & exec)
    for $route (@{$conf{"rewriterules"}}) {
        if ($req =~ /$route/) {
            if (exists $conf{"routes"}{$route}) {
                return ("route", $route, $basedir . $conf{"routes"}{$route});
            } elsif (exists $conf{"exec"}{$route}) {
                return ("exec", $route, $basedir . $conf{"exec"}{$route});
            }
        }
    }

    # Si la route ne correspond à rien, on retourne une 404
    print STDERR "GetPath - Error 404";
    repondre404();
}


# Donne le chemin réel du fichier demandé par la requête
sub getFile
{
    my @route = getPath($_[0]);
    my $p1 = qr/$route[1]/;

    $_ = $_[0];

    my @matches = m/$p1/;
    my $p2 = $route[2];

    for (@matches) {
           $m = $matches[$i++];
           $p2 =~ s{\\$i}{$m};
    }

    m/$p2/;

    if (-d $p2) {
        $p2 = $p2 . "/" . $conf{"global"}{"index"};
    }

    return ($route[0], $p2);
}

sub readFile
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);
    return $contenu;
}

# Renvoie une erreur 404
sub repondre404
{
        # Par défaut, la réponse sera la page définie dans la configuration
    $reponse = readFile($conf{"global"}{"default"});

    # On envoie la réponse
    printf CLIENT   "HTTP/1.1 404 Not Found\r\n" .
                    "Content-Type: text/html\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    # TODO : LOG

    close CLIENT;

    exit 0;
}

sub getpid
{
    open(PID, "$pidServFile");
    $pid = <PID>;
    close(PID);

    return $pid;
}


sub date
{
    my ($s, $mn, $h, $j, $m, $a) = localtime(time);
    my @mois = ("Janvier","Fevrier","Mars","Avril","Mai","Juin","Juillet","Aout","Septembre","Octobre","Novembre","Decembre");
    
    #Formatage de la date
    $s  = ($s  > 10) ? $s  : "0$s";
    $mn = ($mn > 10) ? $mn : "0$mn";
    $h  = ($h  > 10) ? $h  : "0$h";
    $a = $a + 1900;
    
    return "$j $mois[$m] $a - $h:$mn:$s";
}


sub ajouterLog
{
    open(LOG, ">>".$conf{"global"}{"logfile"});
    $, = ";";
    print LOG @_,"\n";
    close(LOG);
}

