#!/usr/bin/perl

use Socket;
if($#ARGV < 0){
    die("Usage : start, stop, status, reload\n");
}

# Récupère la commande
$commande = $ARGV[0];

#Configuration du serveur 
$pidServFile = ".pid";
charger_conf();

#Nombre de clients connecter
@client = ();


if($commande eq "start"){
    if(-f $pidServFile){
	die("Comanche est déjà en cours d'executions\n");
    }
    $SIG{CHLD} = \&retirerfils;
    $pid = fork;
    if($pid != 0){
	open(PID, ">$pidServFile");
	print PID $pid;
	close(PID);
	exit 0;
    }else{
	print "Lancement du serveur en cour\n veuillez patientez...\n";
       
	socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);
	
	$port = $conf{"global"}{"port"};
	$addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidServFile); die("sockaddr_in\n"); };

	bind(SERVEUR, $addr) || do { unlink($pidServFile); die("[ERR] Le port $port est indisponible\n"); };
	listen(SERVEUR, SOMAXCONN) || do { unlink($pidServFile); die("listen $!\n"); };

	ajouterLog(date(),"start","local",$port,"","");

	$start = 1;

	while (accept(CLIENT,SERVEUR) or do { last if $start eq 0; next if $!{EINTR}; die("Accept impossible : $!\n"); } ){
	    autoflush CLIENT 1;
	    if($#client >= $config{"global"}{"clients"}){
		 $reponse  = "<html><body>" .
                             "<h1>503 Service Unavailable</h1>" .
			     "<h2>Trop de connexions simultanées, réessayez plus tard</h2>" .
			     "</body></html>";
		 
		 printf CLIENT  "HTTP/1.1 503 Service Unavailable\r\n" .
                                "Content-Type: text/html; charset=utf-8\r\n" .
				"Content-Length: " . length($reponse) . "\r\n\r\n" .
				$reponse;
	    }else{
		$pid = fork;
	    
		if($pid == 0){
		    
		    $peer = getpeername(CLIENT);
		    ($port, $iaddr) = sockaddr_in($peer);
		    $ip = inet_ntoa($iaddr);
		    
		    $req = <CLIENT>;
		    while(<CLIENT> =~ /^\r?\n/){}#on ne fait rien si le client n'envoie pas de requete
		    
		    $req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || repondre400;
		    
		    
		    
		    $req = $1;
		    
		    @fichier = getFile($req);
		    $exec = $fichier[0] eq "exec";
		    $fichier = $fichier[1];
		    
		    unless(-f $fichier){
			repondre404();
		    }
		    
		    

		    $reponse = readFile($fichier);

		    if($exec) {
			$reponse = cgi($fichier);
			$ext = ".html";
			$type = "get-d";
		    }else{
			$ext = ext($fichier);
			$type = "get-s";
		    }
		    repondre404() unless( $ext eq ".jpg" or $ext eq ".JPG" or $ext eq ".jpeg" or $ext eq ".JPEG" or $ext eq ".txt" or $ext eq ".TXT" or $ext eq ".html" or $ext eq ".HTML" );

		    #Gestion des mimetype
		    $mimetype = "image/jpeg" if($ext eq ".jpg" or $ext eq ".JPG" or $ext eq ".jpeg" or $ext eq ".JPEG");
		    $mimetype = "text/html"  if($ext eq ".html" or $ext eq ".HTML");
		    $mimetype = "text/plain" if($ext eq ".txt" or $ext eq ".TXT");
		    
		    print CLIENT "HTTP/1.1 200 OK\r\n" .
			"Content-Type:".$mimetype." \r\n" .
			"Content-length: " . length($reponse) . "\r\n\r\n" .
			$reponse;
		    
		    ajouterLog(date(),$type,$ip,$req,$fichier,200);
		    close CLIENT;
		    exit 0;
		    
		}
		push(@client,$pid);
	    }
	    close CLIENT;
	}
	close CLIENT;
	close SERVEUR;

    }
}elsif($commande eq "stop"){
    kill QUIT, getpid() || die("Le serveur n'est pas en cour d'execution\n");
    unlink($pidServFile);
    ajouterLog(date(),"stop","local",$conf{"global"}{"port"},"","");
}elsif($commande eq "reload"){
    getpid() || die("Le serveur n'est pas en cour d'execution\n");
    chager_conf;
}elsif($commande eq "status"){

}


sub charger_conf
{
    # Vide la configuration
    undef %conf;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $cle    = $1;
            $valeur = $2;

            if($cle =~ /port/){         # Validation du port TCP
                die("[Erreur configuration] Port invalide\n") unless($valeur =~ /[\d+]/ && $valeur >= 1 && $valeur <= 65535);
            } elsif($cle =~ /clients/){ # Validation du nombre de clients
                die("[Erreur configuration] Nombre de clients invalide\n") unless($valeur =~ /\d+/);
            } elsif($cle =~ /default/){ # Validation du fichier par défaut
                die("[Erreur configuration] Fichier default inaccessible\n") unless(-f $valeur);
            } elsif($cle =~ /basedir/){ # Validation du dossier de base
                die("[Erreur configuration] Dossier de base inaccessible\n") unless(-d $valeur);
            }

            $conf{"global"}{$cle} = $valeur;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $conf{"routes"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $conf{"exec"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } 
    }
    close(CONFIG);
}

# Retourne la route associée à la requête
sub getPath
{
    $req = $_[0];

    # Gestion du dossier de base
    $basedir = "";
    if (exists $config{"global"}{"basedir"}) {
        $basedir = $config{"global"}{"basedir"};
    }

    # Parcours de toutes les règles de réécriture (routes & exec)
    for $route (@{$conf{"rewriterules"}}) {
        if ($req =~ /$route/) {
            if (exists $conf{"routes"}{$route}) {
                return ("route", $route, $basedir . $conf{"routes"}{$route});
            } elsif (exists $conf{"exec"}{$route}) {
                return ("exec", $route, $basedir . $conf{"exec"}{$route});
            }
        }
    }

    # Si la route ne correspond à rien, on retourne une 404
    repondre404();
}


# Donne le chemin réel du fichier demandé par la requête
sub getFile
{
    my @route = getPath($_[0]);
    my $p1 = qr/$route[1]/;

    $_ = $_[0];

    my @matches = m/$p1/;
    my $p2 = $route[2];

    for (@matches) {
           $m = $matches[$i++];
           $p2 =~ s{\\$i}{$m};
    }

    m/$p2/;

    if (-d $p2) {
        $p2 = $p2 . $conf{"global"}{"index"};
    }

    return ($route[0], $p2);
}

sub readFile
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);
    return $contenu;
}

# Renvoie une erreur 404
sub repondre404
{
        # Par défaut, la réponse sera la page définie dans la configuration
    $reponse = readFile($conf{"global"}{"default"});

    # On envoie la réponse
    print CLIENT "HTTP/1.1 404 Not Found\r\n" .
	         "Content-Type: text/html\r\n" .
		 "Content-Length: " . length($reponse) . "\r\n\r\n" .
		 $reponse;

    ajouterLog("get-s", $ip, $req, $conf{"global"}{"default"}, 404);
    close CLIENT;

    exit 0;
}

#meme schema que pour repondre 400;
sub repondre400
{
    $reponse = "<html><head><title>Bad request</title></head><body><h1>Bad Request</h1></body></html>";
    print CLIENT "HTTP/1.1 400 Bad Request\r\n" .
	         "Content-type : text/html\r\n" .
		 "Content-Length: " . length($reponse) . "\r\n\r\n" .
		 $reponse;
    close CLIENT;
    exit 0;

}

sub getpid
{
    open(PID, "$pidServFile");
    $pid = <PID>;
    close(PID);

    return $pid;
}


sub date
{
    my ($s, $mn, $h, $j, $m, $a) = localtime(time);
    my @mois = ("Janvier","Fevrier","Mars","Avril","Mai","Juin","Juillet","Aout","Septembre","Octobre","Novembre","Decembre");
    
    #Formatage de la date
    $s  = ($s  > 10) ? $s  : "0$s";
    $mn = ($mn > 10) ? $mn : "0$mn";
    $h  = ($h  > 10) ? $h  : "0$h";
    $a = $a + 1900;
    
    return "$j $mois[$m] $a - $h:$mn:$s";
}


sub ajouterLog
{
    open(LOG, ">>".$conf{"global"}{"logfile"});
    $, = ";";
    print LOG @_,"\n";
    close(LOG);
}

sub retirerfils
{
    $pid = wait();
    @client = grep { $_ != $pid } @client;
}

sub cgi
{
    return `perl $_[0]`;
}


sub ext
{
    my $fichier = $_[0];
    my ($ext) = $fichier =~ /(\.[^.]+)$/;
    return $ext;
}
