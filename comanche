#!/usr/bin/perl

use Socket;

if($#ARGV < 0){
    die("Usage : start, stop, status, reload\n");
}

# Récupère la commande
$commande = $ARGV[0];

#Configuration du serveur 
$pidServFile = ".pid";
charger_conf();


#Nombre de clients connecter
@client = ();


if($commande eq "start"){
    if(-f $pidServFile){
	die("Comanche est déjà en cours d'executions\n");
    }
    
    $pid = fork;
    if($pid != 0){
	open(PID, ">$pidServFile");
	print PID $pid;
	close(PID);

	exit 0;
    }else{
	print "Lancement du serveur en cour\n veuillez patientez...\n";
	socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);
	
	$port = $conf{"global"}{"port"};
	$addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidServFile); die("sockaddr_in\n"); };
	bind(SERVEUR, $addr) || do { unlink($pidServFile); die("Le port $port est indisponible\n"); };
	listen(SERVEUR, SOMAXCONN) || do { unlink($pidServFile); die("listen $!\n"); };
	print "Serveur lancé sur le port $port \n";
	

	while (accept(CLIENT,SERVEUR)){
	    autoflush CLIENT 1;

	    $pid = fork;
	    
	    if($pid == 0){
		$req = <CLIENT>;
		while(<CLIENT> =~ /^\r?\n/){}#on ne fait rien si le client n'envoie pas de requete
		
		#@fichier = getFile($req);
		repondre404();
		
		close CLIENT;
		exit 0;
		
	    }
	}
	close CLIENT;
	close SERVEUR;

    }
}elsif($commande eq "stop"){
    kill QUIT, getpid() || die("Le serveur n'est pas en cour d'execution\n");
    unlink($pidServFile);
}elsif($commande eq "reload"){
    getpid() || die("Le serveur n'est pas en cour d'execution\n");
    chager_conf;
}elsif($commande eq "status"){

}

sub getPath{
    my $req = $_[0];

    $basedir = $conf{"global"}{"basedir"};
    for $route (@{$config{rewrites}}){
	if( $req =~ /$routes/){
	    if(exists $config{"routes"}{$route}){
		return ("route", $route, basedir . $conf{"routes"}{$route});
	    }
	    elsif(exists $config{"exec"}{$route}){
		return ("exec", $route, basedir . $conf{"exec"}{$route});
	    }
	}
    }

    repondre404();
}


sub getFile {
    my @path = getPath($_[0]);
    my $param1 = qr/$path/;
    
    $_ = $_[0];
    
    my @find = m/$param1/;
    my $param2 = $path[2];
    

    for (@find){
	$f = $find[$i++];
	$param2 =~ s{\\$i}{$f};
    }

    m/$param2/;

    if(-d $param2){
	$param2 = $param2 . "/" . $config{"global"}{"index"};
    }
    return ($route[0],$p2);
}



sub getpid{
    open(GETPID, "$pidServFile");
    $pid = <GETPID>;
    close(GETPID);
    return $pid;
}

sub charger_conf{
    undef %conf;

    open(CONF, "comanche.conf") || die("Impossible de charger le fichier de config");
    while(<CONF>){
	if(/^set\s+(.+)\s+(.+)/){
	    $key = $1; #Key
	    $value = $2;
	    
	    if($key =~ /port/){
		unless($value =~ /[\d+]/ && $value >= 1 && $valeur <= 65535){
		    die("Numero de port invalide");
		}
	    }elsif($key =~ /clients/){
		unless($value =~ /\d+/){
		    die("Nombre de client invalide");
		}
	    }elsif($key =~ /default/){
		unless(-f $value){
		    die("Fichier $value inexistant");
		}
	    }

	    $conf{"global"}{$key} = $value;
	}elsif(/^route\s+(.+?)\s+to\s+(.+)/){
	    $conf{"routes"}{$1} = $2;
	    push(@{$conf{"rewrites"}},$1);
	}elsif(/^exec\s+(.+?)\s+from\s+(.+)/){
	    $conf{"exec"}{$1} = $2;
	    push(@{$conf{"rewrites"}},$1);
	}
	
    }
    close(CONF);
}

sub repondre404
{
     # Par défaut, la réponse sera la page définie dans la configuration
    $reponse = lirefichier($conf{"global"}{"default"});

    # On envoie la réponse
    printf CLIENT   "HTTP/1.1 404 Not Found\r\n" .
                    "Content-Type: text/html\r\n" .
                    "Content-Length: " . length($reponse) . "\r\n\r\n" .
                    $reponse;

    # Ajout au log de la requête effectuée
    #ajouterlog("get-s", $ip, $req, $config{"global"}{"default"}, 404);

    close CLIENT;

    exit 0;
}


sub lirefichier
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);

    return $contenu;
}
