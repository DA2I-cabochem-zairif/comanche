#!/usr/bin/perl

use Socket;
if($#ARGV < 0){
    die("Usage : start, stop, status, reload\n");
}

# Récupère la commande
$commande = $ARGV[0];

#Configuration du serveur 
$pidServFile = ".pid";
charger_conf();

#Nombre de clients connecter
@client = ();

#compteurs de requêtes
$reqRecues  = 0;
$reqTraitees = 0;


if($commande eq "start"){
    if(-f $pidServFile){
	die("Comanche est déjà en cours d'executions\n");
    }
    #Signaux
    $SIG{CHLD} = \&retirerfils;
    $SIG{USR1} = \&status;
    $SIG{QUIT} = \&stop;
    $SIG{HUP}  = \&reload;


    $pid = fork;
    if($pid != 0){
	open(PID, ">$pidServFile");
	print PID $pid;
	close(PID);
	exit 0;
    }else{
	print "Lancement du serveur en cour\n veuillez patientez...\n";
       
	socket(SERVEUR, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
	setsockopt(SERVEUR, SOL_SOCKET, SO_RUSEADDR, 1);
	
	$port = $conf{"global"}{"port"};
	$addr = sockaddr_in($port, INADDR_ANY) || do { unlink($pidServFile); die("sockaddr_in\n"); };

	bind(SERVEUR, $addr) || do { unlink($pidServFile); die("[ERR] Le port $port est indisponible\n"); };
	listen(SERVEUR, SOMAXCONN) || do { unlink($pidServFile); die("listen $!\n"); };

	ajouterLog(date(),"start","local",$port,"","");

	$start = 1;

	while (accept(CLIENT,SERVEUR) or do { last if $start eq 0; next if $!{EINTR}; die("Accept impossible : $!\n"); } ){
	    $reqRecues+=1;
	    autoflush CLIENT 1;
	    if($#client >= $config{"global"}{"clients"}){
		 $reponse  = "<html><body>" .
                             "<h1>503 Service Unavailable</h1>" .
			     "<h2>Trop de connexions simultanées, réessayez plus tard</h2>" .
			     "</body></html>";
		 
		 printf CLIENT  "HTTP/1.1 503 Service Unavailable\r\n" .
                                "Content-Type: text/html; charset=utf-8\r\n" .
				"Content-Length: " . length($reponse) . "\r\n\r\n" .
				$reponse;
	    }else{
		$pid = fork;
	    
		if($pid == 0){
		    
		    $peer = getpeername(CLIENT);
		    ($port, $iaddr) = sockaddr_in($peer);
		    $ip = inet_ntoa($iaddr);
		    
		    $req = <CLIENT>;
		    while(<CLIENT> =~ /^\r?\n/){}#on ne fait rien si le client n'envoie pas de requete
		    
		    $req =~ /(?-i)GET(?i)\s(\/(?:.*))\sHTTP\/1\.1/ || repondre400;
		    
		    
		    
		    $req = $1;
		    
		    @fichier = getFile($req);
		    $exec = $fichier[0] eq "exec";
		    $fichier = $fichier[1];
		    
		    if(-d $fichier){
			$reponse = lister($fichier);
			$ext = ".html";
			$type = "get-d";
		    }else{
			unless(-f $fichier){
			    repondre404();
			}		    
			if($exec) {
			    $reponse = cgi($fichier);
			    $ext = ".html";
			    $type = "get-d";
			}else{
			    $reponse = readFile($fichier);
			    $ext = ext($fichier) || ".html";
			    $type = "get-s";
			}
		    }

		    repondre501() unless( $ext eq ".jpg" or $ext eq ".JPG" or $ext eq ".jpeg" or $ext eq ".JPEG" or $ext eq ".txt" or $ext eq ".TXT" or $ext eq ".html" or $ext eq ".HTML" );

		    #Gestion des mimetype
		    $mimetype = "image/jpeg" if($ext eq ".jpg" or $ext eq ".JPG" or $ext eq ".jpeg" or $ext eq ".JPEG");
		    $mimetype = "text/html"  if($ext eq ".html" or $ext eq ".HTML");
		    $mimetype = "text/plain" if($ext eq ".txt" or $ext eq ".TXT");
		    
		    print CLIENT "HTTP/1.1 200 OK\r\n" .
			"Content-Type:".$mimetype." \r\n" .
			"Content-length: " . length($reponse) . "\r\n\r\n" .
			$reponse;
		    
		    ajouterLog(date(),$type,$ip,$req,$fichier,200);
		    close CLIENT;
		    exit 0;
		    
		}
		push(@client,$pid);
		$reqTraitees ++;
	    }
	    close CLIENT;
	}
	close CLIENT;
	close SERVEUR;

    }
}elsif($commande eq "stop"){
    kill QUIT, getpid() || die("Le serveur n'est pas en cour d'execution\n");
    unlink($pidServFile);
    ajouterLog(date(),"stop","local",$conf{"global"}{"port"},"","");
}elsif($commande eq "reload"){
    kill HUP, getpid() || die("Le serveur n'est pas lancé\n");
}elsif($commande eq "status"){
    kill USR1, getpid() || die("Le serveur n'est pas lancé\n");
}else{
    print "Usage : start, stop, status, reload\n"
}


sub charger_conf
{
    # Vide la configuration
    undef %conf;

    # Charge la configuration depuis le fichier comanche.conf
    open(CONFIG, "comanche.conf") || die("Impossible de charger le fichier de configuration\n");
    while(<CONFIG>) {
        if(/^set\s+(.+)\s+(.+)/){
            $key    = $1;
            $val = $2;

            if($key =~ /port/){         # Validation du port TCP : doit etre compris entre 1 et 65535
                die("[Erreur de configuration] Port invalide (le port doit etre compris entre 1 et 65535)\n") unless($val =~ /[\d+]/ && $val >= 1 && $val <= 65535);
            } elsif($key =~ /clients/){ # Validation du nombre de clients : doit etre un nombre
                die("[Erreur de configuration] Nombre de clients invalide(Doit etre un nombre) \n") unless($val =~ /\d+/);
            } elsif($key =~ /default/){ # Validation du fichier par défaut
                die("[Erreur de configuration] Fichier default introuvable ou inaccessible \n") unless(-f $val);
            } 

            $conf{"global"}{$key} = $val;
        } elsif (/^route\s+(.+?)\s+to\s+(.+)/) {
            $conf{"routes"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } elsif (/^exec\s+(.+?)\s+from\s+(.+)/) {
            $conf{"exec"}{$1} = $2;
            push(@{$conf{"rewriterules"}}, $1);
        } 
    }
    close(CONFIG);
}

# Retourne la route associée à la requête
sub getPath
{
    $req = $_[0];

    # Parcours de toutes les règles de réécriture (routes & exec)
    for $route (@{$conf{"rewriterules"}}) {
        if ($req =~ /$route/) {
            if (exists $conf{"routes"}{$route}) {
                return ("route", $route,  $conf{"routes"}{$route});
            } elsif (exists $conf{"exec"}{$route}) {
                return ("exec", $route, $conf{"exec"}{$route});
            }
        }
    }
    # Si la route ne correspond à rien, on retourne une 404
    repondre404();
}


# Donne le chemin réel du fichier demandé par la requête
sub getFile
{
    my @route = getPath($_[0]);
    my $p1 = qr/$route[1]/;
    $_ = $_[0];
    my @matches = m/$p1/;
    my $p2 = $route[2];
    for (@matches) {
           $m = $matches[$i++];
           $p2 =~ s{\\$i}{$m};
    }
    m/$p2/;
    if (-d $p2) {
	if(-f $p2.$conf{"global"}{"index"}){
	    $p2 = $p2 . $conf{"global"}{"index"};
	}
    }
    return ($route[0], $p2);
}

sub readFile
{
    my $contenu;

    open(FICHIER, $_[0]) || return "";
    while (<FICHIER>) {
        $contenu .= $_;
    }
    close(FICHIER);
    return $contenu;
}

# Renvoie une erreur 404
sub repondre404
{
    # On considere que la page par default est celle qui reponds a une erreur de type 404
    $reponse = readFile($conf{"global"}{"default"});
    $reponse .= "<hr><p>Comanche Version 1</p>";
    # On envoie la réponse
    print CLIENT "HTTP/1.1 404 Not Found\r\n" .
	         "Content-Type: text/html\r\n" .
		 "Content-Length: " . length($reponse) . "\r\n\r\n" .
		 $reponse;

    ajouterLog("get-s", $ip, $req, $conf{"global"}{"default"}, 404);
    close CLIENT;

    exit 0;
}

#meme schema que pour repondre 400;
sub repondre400
{
    $reponse = "<html><head><title>Bad request</title></head><body><h1>Bad Request</h1><hr><p>Comanche Version 1</p></body></html>";
    print CLIENT "HTTP/1.1 400 Bad Request\r\n" .
	         "Content-type : text/html\r\n" .
		 "Content-Length: " . length($reponse) . "\r\n\r\n" .
		 $reponse;
    close CLIENT;
    exit 0;

}
#meme schema que pour repondre 400;
sub repondre501
{
    $reponse = "<html><head><title>Service unvailable</title></head><body><h1>Service unvailable</h1><hr><p>comanche Version 1</p></body></html>";
    print CLIENT "HTTP/1.1 501 Service unvailable\r\n" .
	         "Content-type : text/html\r\n" .
		 "Content-Length: " . length($reponse) . "\r\n\r\n" .
		 $reponse;
    close CLIENT;
    exit 0;

}

sub getpid
{
    open(PID, "$pidServFile");
    $pid = <PID>;
    close(PID);

    return $pid;
}


sub date
{
    my ($s, $mn, $h, $j, $m, $a) = localtime(time);
    my @mois = ("Janvier","Fevrier","Mars","Avril","Mai","Juin","Juillet","Aout","Septembre","Octobre","Novembre","Decembre");
    
    #Formatage de la date
    $s  = ($s  > 10) ? $s  : "0$s";
    $mn = ($mn > 10) ? $mn : "0$mn";
    $h  = ($h  > 10) ? $h  : "0$h";
    $a = $a + 1900;
    
    return "$j $mois[$m] $a - $h:$mn:$s";
}


sub ajouterLog
{
    open(LOG, ">>".$conf{"global"}{"logfile"});
    $, = ";";
    print LOG @_,"\n";
    close(LOG);
}

sub retirerfils
{
    $pid = wait();
    @client = grep { $_ != $pid } @client;
}

sub cgi
{
    return `perl $_[0]`;
}


sub ext
{
    my $fichier = $_[0];
    my ($ext) = $fichier =~ /(\.[^.]+)$/;
    return $ext;
}

sub status
{
    $, = ",";
    print "Numero de processus pere : $$\n" .
	  "Requêtes :\n" .
	  "\trecues : $reqRecues \n" .
	  "\ttraitées : $reqTraitees \n" .
	  "Nombre de clients connectée à l'instant : ".(($#client > 0) ? $#client : "0")." \n";
    print @client;
    close CLIENT;
}

sub stop
{
    $start = 0;

    while (wait != -1) {}
}


sub reload
{
    charger_conf();
}

sub lister
{
    my $reponse = "<html><head><title>Comanche : index of $_[0]</title></head>".
	          "<body><h1>Index of : $_[0]</h1><hr/><ul>";

    opendir(REP,"$_[0]") or die "Impossible d'ouvrir : $dossier_local";
    my @liste = readdir(REP);
    @liste = grep {$_ ne "."} @liste;
    @liste = grep {$_ ne ".."} @liste;
    closedir REP;

    foreach my $i (@liste) {
        if (-d $i) {
         $reponse .= " <li><a href=$i\> $i/</a></li>\n";
        }else{
         $reponse .= " <li><a href=$i> $i</a></li>\n";
        }
    }
    
    $reponse .= "</ul><hr><p>Comanche Version 1</p></body></html>";
    return $reponse;
}
